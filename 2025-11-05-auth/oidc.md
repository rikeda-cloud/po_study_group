# OpenID Connect

OIDCはOAuth 2.0の上に構築された認証のためのプロトコルです。

## OIDCの主な拡張点

- IDトークン:
    - ユーザーの認証情報を`{JWT}`形式で表現したもの。
    - クライアントは`{JWT}`を検証することで、ユーザーが誰であるかを知ることができる。
    OAuthの`{scope}`に`{openid}`を含めることで、IDトークンが返されるようになる。

- UserInfoエンドポイント:
    - IDトークンに含まれる情報だけでは足りない場合に、追加のユーザー情報を取得するためのエンドポイント。
    - このエンドポイントへのアクセスはアクセストークンが必要です。

## OIDCのフロー:

OIDCのフローは、OAuth 2.0のフローをベースにしています。最も一般的に利用されるのは、OAuth 2.0の認可コードフローを拡張した**認可コードフロー**です。

1.  **認証リクエスト**:
    - クライアントは、OAuth 2.0の認可リクエストに加えて、`{scope}`パラメータに`{openid}`を含めて認可サーバにリクエストを送信します。
    - `{response_type}`には`{code}`を指定します。

2.  **ユーザーの認証と同意**:
    - ユーザーは認可サーバ上で認証（ログイン）し、クライアントに要求された情報（scopeで指定）を提供することに同意します。

3.  **認可コードの払い出し**:
    - 認可サーバは、ユーザーをクライアントの`{redirect_uri}`にリダイレクトさせ、`{QueryString}`に認可コードを付与します。

4.  **トークンリクエスト**:
    - クライアントは受け取った認可コードを使い、認可サーバのトークンエンドポイントにリクエストを送信します。このリクエストには、クライアントIDとSecretも含まれます。

5.  **IDトークンとアクセストークンの発行**:
    - 認可サーバは認可コードを検証し、問題がなければクライアントに**IDトークン**と**アクセストークン**を発行します。

6.  **IDトークンの検証とユーザー情報の取得**:
    - クライアントは受け取ったIDトークンの署名を検証し、改ざんされていないことを確認します。
    - 検証後、IDトークンのペイロードからユーザーの識別子（subクレームなど）やその他の情報を取得し、ユーザーを認証します。

7.  **リソースへのアクセス（任意）**:
    - クライアントは、必要に応じて、取得したアクセストークンを使ってUserInfoエンドポイントやその他のリソースサーバにアクセスし、追加のユーザー情報を取得します。

```mermaid
sequenceDiagram
    participant User as リソースオーナー
    participant Client as クライアント
    participant OP as OpenID Provider

    User->>Client: 1. ログインを開始
    Client->>User: 2. 認証リクエスト (scope=openidを含めてリダイレクト)
    User->>OP: 3. 認証リクエスト
    OP->>User: 4. ログイン & 同意画面を要求
    User->>OP: 5. ログイン & 同意
    OP->>User: 6. 認可コードを付与してリダイレクト
    User->>Client: 7. 認可コードを渡す

    Client->>OP: 8. 認可コード、Secret情報等を送信
    OP->>Client: 9. IDトークンとアクセストークンを発行

    Client->>Client: 10. IDトークンを検証し、ユーザーを認証

    Client->>OP: 11. アクセストークンを使いUserInfoエンドポイントにリクエスト
    OP->>Client: 12. ユーザー情報を返却
```
